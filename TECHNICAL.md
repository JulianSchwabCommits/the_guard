# üîß The Guard - Technische Entwickler-Dokumentation

**Detaillierte Architektur und Implementierungs-Details**

---

## üìã Inhaltsverzeichnis

1. [Architektur-√úbersicht](#architektur-√ºbersicht)
2. [Klassen-Dokumentation](#klassen-dokumentation)
3. [Game Loop Mechanik](#game-loop-mechanik)
4. [Design Patterns](#design-patterns)
5. [Datenstrukturen](#datenstrukturen)
6. [Erweiterungsm√∂glichkeiten](#erweiterungsm√∂glichkeiten)

---

## üèóÔ∏è Architektur-√úbersicht

### Layer-Architektur (Bottom-Up)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         GuardGame (Main Loop)           ‚îÇ  ‚Üê Layer 4: Game Logic
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Parser | CommandWords | Command       ‚îÇ  ‚Üê Layer 3: Input System
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     Player | Guard | Room                ‚îÇ  ‚Üê Layer 2: Game Entities
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Item | ItemType | GameState           ‚îÇ  ‚Üê Layer 1: Data Models
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Dependency Graph

```
GuardGame
  ‚îú‚îÄ‚Üí Parser
  ‚îÇ    ‚îî‚îÄ‚Üí CommandWords
  ‚îÇ    ‚îî‚îÄ‚Üí Command
  ‚îú‚îÄ‚Üí Player
  ‚îÇ    ‚îî‚îÄ‚Üí Room
  ‚îÇ    ‚îî‚îÄ‚Üí Item
  ‚îú‚îÄ‚Üí Guard
  ‚îÇ    ‚îî‚îÄ‚Üí Room
  ‚îú‚îÄ‚Üí GameState (enum)
  ‚îî‚îÄ‚Üí Room
       ‚îî‚îÄ‚Üí Item
            ‚îî‚îÄ‚Üí ItemType (enum)
```

---

## üìö Klassen-Dokumentation

### 1. GuardGame.java

**Verantwortlichkeiten:**
- Hauptspiel-Orchestrierung
- Raum-Erstellung und Verbindung
- Game Loop Management
- Win/Loss Condition Checking

**Wichtige Methoden:**

```java
public GuardGame()
// Initialisiert:
// - Parser f√ºr Input
// - 16 R√§ume mit Items/Verstecken
// - Player (Start: Empfangshalle)
// - Guard (Start: √úberwachungsraum)
// - GameState = PLAYING

public void play()
// Hauptspiel-Schleife:
// 1. Player resetTurn() ‚Üí 2 neue Aktionen
// 2. While (actionsRemaining > 0)
//    - Befehl einlesen
//    - Befehl verarbeiten
// 3. Guard bewegt sich
// 4. Game Over Check
// 5. Repeat bis gameState != PLAYING

private void createRooms()
// Erstellt alle 16 R√§ume
// Setzt Exits (north/south/east/west)
// Ruft setup-Methoden auf

private void setupXXX(Room room)
// Konfiguriert einzelne R√§ume:
// - addSearchableLocation()
// - addHidingSpot()
// - addItem()

private void processCommand(Command command)
// Switch-Statement f√ºr Befehle:
// - help, go, search, hide
// - use, inventory, next, quit

private void checkGameOver()
// Pr√ºft: guard.isInSameRoom(player) && !player.isHidden()
// ‚Üí GameState.PLAYER_CAUGHT
```

**Design-Entscheidungen:**

1. **Warum separate setup-Methoden?**
   - Bessere Lesbarkeit
   - Einfacher zu erweitern
   - Klare Separation of Concerns

2. **Warum HashMap f√ºr R√§ume?**
   ```java
   private Map<String, Room> rooms;
   ```
   - Schneller Zugriff per Name
   - Einfache Erweiterung
   - Alternative: Array (schlechter)

---

### 2. Player.java

**Verantwortlichkeiten:**
- Inventar-Management
- Aktions-Tracking (2 pro Runde)
- Versteck-Mechanik
- Movement mit Einschr√§nkungen

**Wichtige Attribute:**

```java
private Room currentRoom;              // Aktuelle Position
private List<Item> inventory;          // Gesammelte Items
private boolean isHidden;              // Versteck-Status
private int actionsPerTurn = 2;        // Max Aktionen
private int actionsRemaining;          // √úbrige Aktionen
private boolean hasMovedThisTurn;     // Movement-Lock
```

**Wichtige Methoden:**

```java
public boolean move(Room room)
// Checks:
// 1. hasMovedThisTurn? ‚Üí return false
// 2. actionsRemaining <= 0? ‚Üí return false
// 3. ‚úÖ Bewege, setze isHidden = false
// 4. useAction(), hasMovedThisTurn = true

public boolean hide()
// Checks:
// 1. actionsRemaining <= 0? ‚Üí return false
// 2. !currentRoom.canHideHere()? ‚Üí return false
// 3. ‚úÖ isHidden = true, useAction()

public void addToInventory(Item item)
// F√ºgt Item hinzu
// Ausgabe: "Du hast X aufgehoben!"

public boolean hasItemType(ItemType type)
// Durchsucht Inventar nach Typ
// Verwendet von: hasWeapon(), hasKey(), hasTeleporter()

public void resetTurn()
// Setzt zur√ºck:
// - actionsRemaining = actionsPerTurn
// - hasMovedThisTurn = false
// Wird von GuardGame.play() pro Runde aufgerufen
```

**Design-Entscheidungen:**

1. **Warum hasMovedThisTurn?**
   ```java
   // Problem ohne Flag:
   move(room1); move(room2); // 2x bewegen in 1 Runde!
   
   // L√∂sung mit Flag:
   move(room1); // OK, flag = true
   move(room2); // BLOCKED! "Nur 1x bewegen pro Runde"
   ```

2. **Warum isHidden bei move() auf false?**
   - Realistisch: Bewegung macht L√§rm
   - Balance: Verhindert "versteckt durchs Spiel laufen"
   - Gameplay: Spieler muss strategisch verstecken

---

### 3. Guard.java

**Verantwortlichkeiten:**
- Zuf√§llige Raum-Bewegung
- Collision-Detection mit Player

**Wichtige Methoden:**

```java
public void moveRandomly()
// Algorithmus:
// 1. Hole alle Exits vom currentRoom
// 2. Filter: nur nicht-null R√§ume
// 3. W√§hle zuf√§lligen Exit
// 4. Bewege zu diesem Raum
// 5. Ausgabe: "üö® Du h√∂rst Schritte..."

public boolean isInSameRoom(Player player)
// return currentRoom == player.getCurrentRoom();
```

**Algorithmus-Details:**

```java
List<String> directions = currentRoom.getExits().keySet().stream()
    .filter(direction -> currentRoom.nextRoom(direction) != null)
    .collect(Collectors.toList());

if (!directions.isEmpty()) {
    String randomDirection = directions.get(random.nextInt(directions.size()));
    currentRoom = currentRoom.nextRoom(randomDirection);
}
```

**Warum Stream API?**
- Filtert null-Exits automatisch
- Funktional und lesbar
- Java 8+ Standard

---

### 4. Room.java

**Verantwortlichkeiten:**
- Raum-Beschreibung
- Exit-Management
- Item-Container
- Such- und Versteck-Orte

**Wichtige Attribute:**

```java
private String description;                    // "in der K√ºche"
private HashMap<String, Room> exits;          // north/south/east/west
private List<Item> items;                     // Items im Raum
private List<String> searchableLocations;     // "chest", "desk"
private List<String> hidingSpots;             // "hinter Theke"
private Random random;                        // F√ºr getRandomHidingSpot()
```

**Wichtige Methoden:**

```java
public void setExits(Room north, Room east, Room south, Room west)
// Setzt alle 4 Himmelsrichtungen
// null = keine T√ºr in diese Richtung

public List<Item> search(String location)
// Algorithmus:
// 1. Ist location in searchableLocations? Nein ‚Üí return []
// 2. Finde alle items mit isVisible() == false
// 3. Setze diese auf isVisible() = true
// 4. Return gefundene Items
// Ausgabe: "Du hast gefunden: ..."

public boolean canHideHere()
// return !hidingSpots.isEmpty();

public String getRandomHidingSpot()
// W√§hlt zuf√§lliges Element aus hidingSpots
// F√ºr Ausgabe: "Du versteckst dich HIER"
```

**Design-Entscheidungen:**

1. **Warum separate Lists f√ºr searchableLocations und items?**
   ```java
   // searchableLocations = WO kann gesucht werden
   // items = WAS liegt hier
   
   // Vorteil:
   search("chest");     // Sucht in Truhe
   search("desk");      // Sucht in Schreibtisch
   // ‚Üí Verschiedene Orte, verschiedene Items
   ```

2. **Warum isVisible() Flag?**
   ```java
   // Phase 1: Item existiert, aber unsichtbar
   addItem(new Item("Schl√ºssel", ...));  // isVisible = false
   
   // Phase 2: Spieler sucht
   search("desk");  // Findet Item, setzt isVisible = true
   
   // Phase 3: Item ist jetzt sichtbar
   showVisibleItems();  // Zeigt Schl√ºssel an
   ```

---

### 5. Item.java

**Verantwortlichkeiten:**
- Item-Daten (Name, Beschreibung, Typ)
- Sichtbarkeits-Status
- Verwendbarkeits-Check

```java
public class Item {
    private String name;           // "Schl√ºssel"
    private String description;    // "Ein goldener Schl√ºssel"
    private ItemType type;         // WEAPON/KEY/TELEPORTER/HINT/TOOL
    private boolean isVisible;     // Anfangs false
}
```

**Warum isUsable()?**
```java
public boolean isUsable() {
    return type == ItemType.WEAPON || 
           type == ItemType.KEY || 
           type == ItemType.TELEPORTER;
}

// Verwendung in GuardGame:
if (item.isUsable()) {
    // Kann mit "use" benutzt werden
}
```

---

### 6. Enums

#### ItemType.java
```java
public enum ItemType {
    WEAPON,      // Messer, Pistole
    KEY,         // Schl√ºssel zum Entkommen
    TELEPORTER,  // Easter Egg
    HINT,        // Hinweis-Notizen
    TOOL         // Taschenlampe, etc.
}
```

**Warum Enum statt String?**
- Type-Safety: Compiler pr√ºft
- Keine Tippfehler: `WEAPON` vs "weapn"
- IDE-Unterst√ºtzung: Auto-Complete

#### GameState.java
```java
public enum GameState {
    PLAYING,                    // Spiel l√§uft
    PLAYER_WON_WEAPON,         // Sieg: W√§chter besiegt
    PLAYER_WON_KEY,            // Sieg: Entkommen
    PLAYER_WON_TELEPORTER,     // Sieg: Teleportiert
    PLAYER_CAUGHT,             // Niederlage
    QUIT                       // Abgebrochen
}
```

**Vorteile:**
- Klarer State-Machine
- Einfache Erweiterung (z.B. PAUSE)
- Switch-Statement freundlich

---

## üîÑ Game Loop Mechanik

### Detaillierter Ablauf

```java
public void play() {
    printWelcome();
    
    while (gameState == GameState.PLAYING) {
        // ============ PHASE 1: RESET ============
        player.resetTurn();      // 2 neue Aktionen
        printRoomInfo();         // Zeige wo du bist
        
        // ============ PHASE 2: PLAYER ACTIONS ============
        while (player.getActionsRemaining() > 0 && 
               gameState == GameState.PLAYING) {
            
            System.out.println("üìä Aktionen √ºbrig: " + 
                             player.getActionsRemaining());
            
            Command command = parser.getCommand();  // Lese Input
            processCommand(command);               // F√ºhre aus
        }
        
        // ============ PHASE 3: GUARD MOVEMENT ============
        if (gameState == GameState.PLAYING) {
            guard.moveRandomly();    // W√§chter bewegt sich
            checkGameOver();         // Pr√ºfe Kollision
        }
    }
    
    // ============ PHASE 4: GAME END ============
    printGameEnd();
}
```

### State-Transitions

```
[PLAYING]
    ‚Üì
    ‚îú‚îÄ‚Üí use key ‚Üí [PLAYER_WON_KEY]
    ‚îú‚îÄ‚Üí use weapon (versteckt + guard da) ‚Üí [PLAYER_WON_WEAPON]
    ‚îú‚îÄ‚Üí use teleporter ‚Üí [PLAYER_WON_TELEPORTER]
    ‚îú‚îÄ‚Üí guard catches player ‚Üí [PLAYER_CAUGHT]
    ‚îî‚îÄ‚Üí quit ‚Üí [QUIT]
    
Alle au√üer PLAYING ‚Üí printGameEnd() ‚Üí EXIT
```

---

## üé® Design Patterns

### 1. Command Pattern
```java
// Parser liest Input
Command command = parser.getCommand();

// GuardGame interpretiert Command
processCommand(command);

// Vorteil: Separation Input ‚Üî Logic
```

### 2. State Pattern (GameState)
```java
enum GameState { PLAYING, WON, LOST, ... }

// Zentrale State-Verwaltung
if (gameState == PLAYING) { ... }
```

### 3. Observer Pattern (implizit)
```java
// Guard bewegt sich ‚Üí Spieler h√∂rt es
guard.moveRandomly();
System.out.println("üö® Du h√∂rst Schritte...");
```

### 4. Factory Pattern (Raum-Erstellung)
```java
private void setupKueche(Room room) {
    room.addSearchableLocation("cabinets");
    room.addHidingSpot("hinter Theke");
    room.addItem(new Item("Messer", ...));
}
```

---

## üìä Datenstrukturen

### HashMap f√ºr R√§ume
```java
Map<String, Room> rooms = new HashMap<>();
rooms.put("kueche", kuecheRoom);

// Warum HashMap?
// ‚úÖ O(1) Zugriff
// ‚úÖ Lesbare Keys
// ‚ùå Kein Index-Zugriff (egal, nicht n√∂tig)
```

### List f√ºr Items
```java
List<Item> inventory = new ArrayList<>();

// Warum ArrayList?
// ‚úÖ Dynamische Gr√∂√üe
// ‚úÖ Iteration einfach
// ‚úÖ add/remove O(1) am Ende
```

### List f√ºr searchableLocations
```java
List<String> searchableLocations = new ArrayList<>();

// Alternative: Set?
// Nein - Duplikate sind OK, Reihenfolge egal
```

---

## üöÄ Erweiterungsm√∂glichkeiten

### 1. Locked Doors

**Implementierung:**
```java
// In Room.java
private Map<String, Boolean> lockedExits;  // direction ‚Üí locked?
private Map<String, ItemType> keyRequired; // direction ‚Üí welcher Schl√ºssel?

public boolean canGo(String direction, Player player) {
    if (!lockedExits.get(direction)) return true;
    
    ItemType requiredKey = keyRequired.get(direction);
    return player.hasItemType(requiredKey);
}
```

**Verwendung:**
```java
tresorRaum.lockExit("west", ItemType.KEY);

// Beim "go":
if (!currentRoom.canGo(direction, player)) {
    System.out.println("üîí Die T√ºr ist verschlossen!");
}
```

---

### 2. Guard-Tracking System

**Implementierung:**
```java
// In Guard.java
public int getDistanceToPlayer(Player player) {
    // BFS-Algorithmus zur Distanz-Berechnung
    return calculateDistance(currentRoom, player.getCurrentRoom());
}

// In GuardGame.java
int distance = guard.getDistanceToPlayer(player);
if (distance == 1) {
    System.out.println("üö® Die Schritte sind SEHR NAH!");
} else if (distance <= 3) {
    System.out.println("üëÇ Du h√∂rst entfernte Schritte...");
}
```

---

### 3. Schwierigkeitsgrade

**Implementierung:**
```java
public enum Difficulty {
    EASY,    // Guard bewegt sich langsam
    NORMAL,  // Standard
    HARD     // Guard bewegt sich schnell + tracking
}

// In GuardGame:
private Difficulty difficulty;

public void play() {
    while (...) {
        // Player phase
        
        // Guard phase
        if (difficulty == HARD) {
            guard.moveTowardsPlayer(player);  // Intelligente Bewegung!
        } else {
            guard.moveRandomly();
        }
    }
}
```

---

### 4. Save/Load System

**Implementierung:**
```java
// Serialisierbare GameState-Klasse
public class SaveState implements Serializable {
    private Room playerRoom;
    private Room guardRoom;
    private List<Item> inventory;
    private GameState gameState;
}

// Speichern:
public void saveGame(String filename) {
    SaveState state = new SaveState(player, guard, ...);
    ObjectOutputStream oos = new ObjectOutputStream(
        new FileOutputStream(filename)
    );
    oos.writeObject(state);
}

// Laden:
public void loadGame(String filename) {
    ObjectInputStream ois = new ObjectInputStream(
        new FileInputStream(filename)
    );
    SaveState state = (SaveState) ois.readObject();
    // Restore game state
}
```

---

### 5. Multi-Guard System

**Implementierung:**
```java
// In GuardGame:
private List<Guard> guards;

public void play() {
    while (...) {
        // Player phase
        
        // Guard phase
        for (Guard guard : guards) {
            guard.moveRandomly();
            
            if (guard.isInSameRoom(player) && !player.isHidden()) {
                gameState = GameState.PLAYER_CAUGHT;
                System.out.println("üíÄ W√§chter #" + guard.getId() + 
                                 " hat dich erwischt!");
                break;
            }
        }
    }
}
```

---

## üß™ Testing-Strategie

### Unit Tests (Beispiele)

```java
@Test
public void testPlayerInventory() {
    Player player = new Player(startRoom);
    Item key = new Item("Schl√ºssel", "...", ItemType.KEY);
    
    assertFalse(player.hasKey());
    player.addToInventory(key);
    assertTrue(player.hasKey());
}

@Test
public void testPlayerCanOnlyMoveOnce() {
    Player player = new Player(startRoom);
    
    assertTrue(player.move(room1));   // First move: OK
    assertFalse(player.move(room2));  // Second move: BLOCKED
    
    player.resetTurn();
    assertTrue(player.move(room2));   // New turn: OK again
}

@Test
public void testGuardRandomMovement() {
    Guard guard = new Guard(startRoom);
    Room initialRoom = guard.getCurrentRoom();
    
    guard.moveRandomly();
    
    assertNotEquals(initialRoom, guard.getCurrentRoom());
}
```

---

## üìà Performance-Analyse

### Komplexit√§t

| Operation | Komplexit√§t | Begr√ºndung |
|-----------|-------------|------------|
| `player.move()` | O(1) | Direkte Zuweisung |
| `guard.moveRandomly()` | O(n) | n = Anzahl Exits |
| `room.search()` | O(m) | m = Anzahl Items |
| `player.hasItemType()` | O(k) | k = Inventar-Gr√∂√üe |
| Game Loop Iteration | O(1) | Konstante Operationen |

**Gesamt-Komplexit√§t pro Runde:**
O(n + m + k) ‚âà O(1) bei kleinen Werten

---

## üîê Code-Qualit√§t

### Naming Conventions
```java
// Klassen: PascalCase
public class GuardGame { }

// Methoden: camelCase
public void moveRandomly() { }

// Konstanten: UPPER_SNAKE_CASE
public static final int MAX_ACTIONS = 2;

// Variablen: camelCase
private boolean isHidden;
```

### Error Handling
```java
// Defensive Programming
if (!command.hasSecondWord()) {
    System.out.println("Wohin m√∂chtest du gehen?");
    return;  // Early return
}

// Null-Checks
if (nextRoom == null) {
    System.out.println("‚ùå Da ist keine T√ºr!");
}
```

---

## üìö Verwendete Java-Features

| Feature | Version | Verwendung |
|---------|---------|------------|
| Enums | Java 5+ | ItemType, GameState |
| Generics | Java 5+ | List<Item>, Map<String, Room> |
| Stream API | Java 8+ | Filter, Collect |
| Lambda | Java 8+ | `.filter(item -> ...)` |
| Try-with-resources | Java 7+ | (F√ºr Save/Load) |

---

**Erstellt von:** Fabian & Julian  
**Projekt:** The Guard - BBW Apprenticeship  
**Datum:** Oktober 2025  
**Version:** 1.0
